{
  "meta": {
    "instanceId": "n8n-agent-workflow-4",
    "name": "Marketing Automation Intelligence - AI Agent v4",
    "description": "Advanced marketing automation workflow with machine learning-driven campaign optimization, multi-channel orchestration, predictive engagement timing, real-time behavioral analysis, automated A/B testing with statistical significance, and customer journey personalization based on contextual intelligence",
    "version": 1,
    "tags": ["ai-agent", "automation", "n8n-mcp", "marketing-automation", "machine-learning", "multi-channel", "personalization", "behavioral-analysis", "ab-testing", "customer-journey"]
  },
  "nodes": [
    {
      "parameters": {
        "path": "/webhook/customer-event",
        "options": {
          "rawBody": true,
          "responseMode": "responseNode"
        }
      },
      "id": "customer-event-webhook",
      "name": "Customer Event Ingestion",
      "type": "n8n-nodes-base.Webhook",
      "typeVersion": 1,
      "position": [200, 400],
      "notes": "Real-time customer event ingestion from web, mobile, email, and social touchpoints. Captures behavioral signals for immediate processing and contextual analysis."
    },
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        }
      },
      "id": "behavioral-data-collector",
      "name": "Behavioral Data Collector",
      "type": "n8n-nodes-base.Cron",
      "typeVersion": 1,
      "position": [200, 600],
      "notes": "Continuous behavioral data collection from multiple sources including website analytics, email engagement, social media interactions, and purchase history for comprehensive customer profiling."
    },
    {
      "parameters": {
        "jsCode": "// Advanced Customer Intelligence Engine with ML-driven Insights\nconst items = $input.all();\nconst processedCustomers = [];\nconst engagementModels = {};\nconst channelPreferences = {};\nconst behavioralSegments = {};\n\n// Machine Learning Models Configuration\nconst mlModels = {\n  engagement_prediction: {\n    weights: {\n      email_open_rate: 0.25,\n      click_through_rate: 0.30,\n      website_session_duration: 0.20,\n      purchase_frequency: 0.35,\n      social_engagement: 0.15,\n      content_consumption: 0.20\n    },\n    features: ['recency', 'frequency', 'monetary', 'engagement_score', 'channel_preference']\n  },\n  churn_prediction: {\n    risk_factors: {\n      declining_engagement: 0.40,\n      support_tickets: 0.25,\n      feature_usage_drop: 0.30,\n      payment_issues: 0.35\n    },\n    time_windows: [7, 14, 30, 90] // days\n  },\n  optimal_timing: {\n    channels: {\n      email: { peak_hours: [9, 11, 14, 16], peak_days: [1, 2, 3, 4] },\n      sms: { peak_hours: [10, 12, 15, 18], peak_days: [1, 2, 3, 4, 5] },\n      push: { peak_hours: [8, 12, 17, 20], peak_days: [0, 1, 2, 3, 4, 5, 6] },\n      social: { peak_hours: [7, 12, 17, 21], peak_days: [0, 1, 2, 3, 4, 5, 6] }\n    }\n  }\n};\n\n// Customer Journey Stages with AI-driven progression logic\nconst journeyStages = {\n  awareness: { weight: 1.0, next_stages: ['consideration'], typical_duration: 7 },\n  consideration: { weight: 1.5, next_stages: ['evaluation', 'trial'], typical_duration: 14 },\n  evaluation: { weight: 2.0, next_stages: ['trial', 'purchase'], typical_duration: 21 },\n  trial: { weight: 2.5, next_stages: ['purchase', 'churn'], typical_duration: 14 },\n  purchase: { weight: 3.0, next_stages: ['onboarding', 'advocacy'], typical_duration: 1 },\n  onboarding: { weight: 2.8, next_stages: ['retention', 'expansion'], typical_duration: 30 },\n  retention: { weight: 3.2, next_stages: ['expansion', 'advocacy', 'churn'], typical_duration: 90 },\n  expansion: { weight: 4.0, next_stages: ['advocacy', 'retention'], typical_duration: 45 },\n  advocacy: { weight: 5.0, next_stages: ['retention', 'expansion'], typical_duration: 365 },\n  churn: { weight: 0.1, next_stages: ['reactivation'], typical_duration: 180 },\n  reactivation: { weight: 1.2, next_stages: ['consideration', 'churn'], typical_duration: 30 }\n};\n\nfunction calculateEngagementScore(customerData) {\n  const model = mlModels.engagement_prediction;\n  let score = 0;\n  \n  // Recency score (last interaction)\n  const lastInteraction = new Date(customerData.last_interaction || customerData.created_at);\n  const daysSinceInteraction = (Date.now() - lastInteraction.getTime()) / (1000 * 60 * 60 * 24);\n  const recencyScore = Math.max(0, 1 - (daysSinceInteraction / 30));\n  \n  // Frequency score (interaction frequency)\n  const interactionCount = customerData.interaction_count || 1;\n  const accountAge = (Date.now() - new Date(customerData.created_at).getTime()) / (1000 * 60 * 60 * 24);\n  const frequencyScore = Math.min(1, interactionCount / Math.max(1, accountAge / 7));\n  \n  // Monetary score (purchase behavior)\n  const totalSpent = customerData.total_spent || 0;\n  const avgOrderValue = customerData.avg_order_value || 0;\n  const monetaryScore = Math.min(1, (totalSpent / 1000) + (avgOrderValue / 100));\n  \n  // Channel engagement scores\n  const emailScore = (customerData.email_open_rate || 0) * model.weights.email_open_rate;\n  const clickScore = (customerData.click_through_rate || 0) * model.weights.click_through_rate;\n  const sessionScore = Math.min(1, (customerData.avg_session_duration || 0) / 300) * model.weights.website_session_duration;\n  const purchaseScore = Math.min(1, (customerData.purchase_frequency || 0) / 12) * model.weights.purchase_frequency;\n  const socialScore = Math.min(1, (customerData.social_engagement_score || 0) / 100) * model.weights.social_engagement;\n  const contentScore = Math.min(1, (customerData.content_engagement_score || 0) / 100) * model.weights.content_consumption;\n  \n  score = (recencyScore + frequencyScore + monetaryScore + emailScore + clickScore + sessionScore + purchaseScore + socialScore + contentScore) / 3;\n  \n  return Math.min(1, Math.max(0, score));\n}\n\nfunction predictChurnRisk(customerData) {\n  const model = mlModels.churn_prediction;\n  let riskScore = 0;\n  \n  // Declining engagement analysis\n  const currentEngagement = calculateEngagementScore(customerData);\n  const historicalEngagement = customerData.historical_engagement_avg || currentEngagement;\n  const engagementDecline = Math.max(0, historicalEngagement - currentEngagement);\n  riskScore += engagementDecline * model.risk_factors.declining_engagement;\n  \n  // Support ticket analysis\n  const recentTickets = customerData.support_tickets_30d || 0;\n  const ticketRisk = Math.min(1, recentTickets / 5);\n  riskScore += ticketRisk * model.risk_factors.support_tickets;\n  \n  // Feature usage analysis\n  const currentUsage = customerData.feature_usage_score || 0.5;\n  const previousUsage = customerData.previous_usage_score || currentUsage;\n  const usageDrop = Math.max(0, previousUsage - currentUsage);\n  riskScore += usageDrop * model.risk_factors.feature_usage_drop;\n  \n  // Payment issues analysis\n  const paymentIssues = customerData.payment_failures_90d || 0;\n  const paymentRisk = Math.min(1, paymentIssues / 3);\n  riskScore += paymentRisk * model.risk_factors.payment_issues;\n  \n  return Math.min(1, riskScore);\n}\n\nfunction optimizeChannelTiming(customerData, timezone = 'UTC') {\n  const timingModel = mlModels.optimal_timing;\n  const personalizedTiming = {};\n  \n  // Analyze historical engagement patterns\n  const historicalPatterns = customerData.engagement_patterns || {};\n  \n  Object.keys(timingModel.channels).forEach(channel => {\n    const channelData = timingModel.channels[channel];\n    const personalPattern = historicalPatterns[channel] || {};\n    \n    // Combine global patterns with personal preferences\n    const optimalHours = personalPattern.peak_hours || channelData.peak_hours;\n    const optimalDays = personalPattern.peak_days || channelData.peak_days;\n    \n    // Calculate next optimal send time\n    const now = new Date();\n    const nextOptimalTime = calculateNextOptimalTime(now, optimalHours, optimalDays, timezone);\n    \n    personalizedTiming[channel] = {\n      next_optimal_time: nextOptimalTime,\n      confidence_score: personalPattern.peak_hours ? 0.9 : 0.6,\n      fallback_hours: channelData.peak_hours,\n      recommended_frequency: calculateOptimalFrequency(customerData, channel)\n    };\n  });\n  \n  return personalizedTiming;\n}\n\nfunction calculateNextOptimalTime(currentTime, optimalHours, optimalDays, timezone) {\n  const now = new Date(currentTime);\n  const currentHour = now.getHours();\n  const currentDay = now.getDay();\n  \n  // Find next optimal hour today\n  const todayOptimalHours = optimalHours.filter(hour => hour > currentHour);\n  \n  if (todayOptimalHours.length > 0 && optimalDays.includes(currentDay)) {\n    const nextHour = todayOptimalHours[0];\n    const nextTime = new Date(now);\n    nextTime.setHours(nextHour, 0, 0, 0);\n    return nextTime.toISOString();\n  }\n  \n  // Find next optimal day\n  for (let dayOffset = 1; dayOffset <= 7; dayOffset++) {\n    const checkDate = new Date(now);\n    checkDate.setDate(now.getDate() + dayOffset);\n    const checkDay = checkDate.getDay();\n    \n    if (optimalDays.includes(checkDay)) {\n      const nextTime = new Date(checkDate);\n      nextTime.setHours(optimalHours[0], 0, 0, 0);\n      return nextTime.toISOString();\n    }\n  }\n  \n  // Fallback to tomorrow at first optimal hour\n  const fallbackTime = new Date(now);\n  fallbackTime.setDate(now.getDate() + 1);\n  fallbackTime.setHours(optimalHours[0], 0, 0, 0);\n  return fallbackTime.toISOString();\n}\n\nfunction calculateOptimalFrequency(customerData, channel) {\n  const engagementScore = calculateEngagementScore(customerData);\n  const baseFrequencies = {\n    email: { min: 1, max: 14, optimal: 7 },\n    sms: { min: 3, max: 30, optimal: 14 },\n    push: { min: 1, max: 7, optimal: 3 },\n    social: { min: 1, max: 3, optimal: 1 }\n  };\n  \n  const channelFreq = baseFrequencies[channel] || baseFrequencies.email;\n  \n  // Adjust frequency based on engagement\n  if (engagementScore > 0.8) {\n    return Math.max(channelFreq.min, channelFreq.optimal * 0.7); // More frequent for highly engaged\n  } else if (engagementScore > 0.5) {\n    return channelFreq.optimal; // Standard frequency\n  } else {\n    return Math.min(channelFreq.max, channelFreq.optimal * 1.5); // Less frequent for low engagement\n  }\n}\n\nfunction determineJourneyStage(customerData) {\n  const signals = {\n    website_visits: customerData.website_visits || 0,\n    email_engagement: customerData.email_engagement_score || 0,\n    content_downloads: customerData.content_downloads || 0,\n    demo_requests: customerData.demo_requests || 0,\n    trial_signup: customerData.trial_signup || false,\n    purchases: customerData.purchase_count || 0,\n    support_usage: customerData.support_usage || 0,\n    referrals_made: customerData.referrals_made || 0,\n    account_age_days: (Date.now() - new Date(customerData.created_at).getTime()) / (1000 * 60 * 60 * 24)\n  };\n  \n  // Journey stage determination logic\n  if (signals.referrals_made > 0 || (signals.purchases > 3 && signals.support_usage > 10)) {\n    return 'advocacy';\n  } else if (signals.purchases > 1 && signals.account_age_days > 90) {\n    return 'expansion';\n  } else if (signals.purchases > 0) {\n    return signals.account_age_days < 30 ? 'onboarding' : 'retention';\n  } else if (signals.trial_signup) {\n    return 'trial';\n  } else if (signals.demo_requests > 0 || signals.content_downloads > 2) {\n    return 'evaluation';\n  } else if (signals.website_visits > 1 || signals.email_engagement > 0.3) {\n    return 'consideration';\n  } else {\n    return 'awareness';\n  }\n}\n\nfunction generatePersonalizedCampaigns(customerData, journeyStage, channelTiming) {\n  const campaigns = [];\n  const stage = journeyStages[journeyStage];\n  \n  // Campaign templates based on journey stage\n  const campaignTemplates = {\n    awareness: [\n      { type: 'educational_content', priority: 'high', channels: ['email', 'social'] },\n      { type: 'brand_introduction', priority: 'medium', channels: ['email', 'push'] }\n    ],\n    consideration: [\n      { type: 'product_showcase', priority: 'high', channels: ['email', 'push'] },\n      { type: 'customer_stories', priority: 'medium', channels: ['email', 'social'] },\n      { type: 'comparison_guide', priority: 'medium', channels: ['email'] }\n    ],\n    evaluation: [\n      { type: 'demo_invitation', priority: 'high', channels: ['email', 'sms'] },\n      { type: 'free_trial', priority: 'high', channels: ['email', 'push', 'sms'] },\n      { type: 'consultative_content', priority: 'medium', channels: ['email'] }\n    ],\n    trial: [\n      { type: 'onboarding_sequence', priority: 'high', channels: ['email', 'push'] },\n      { type: 'feature_education', priority: 'high', channels: ['email', 'push'] },\n      { type: 'success_metrics', priority: 'medium', channels: ['email'] }\n    ],\n    purchase: [\n      { type: 'welcome_sequence', priority: 'high', channels: ['email'] },\n      { type: 'setup_assistance', priority: 'high', channels: ['email', 'sms'] }\n    ],\n    onboarding: [\n      { type: 'progressive_feature_reveal', priority: 'high', channels: ['email', 'push'] },\n      { type: 'best_practices', priority: 'medium', channels: ['email'] },\n      { type: 'community_invitation', priority: 'low', channels: ['email', 'social'] }\n    ],\n    retention: [\n      { type: 'usage_insights', priority: 'medium', channels: ['email'] },\n      { type: 'feature_updates', priority: 'medium', channels: ['email', 'push'] },\n      { type: 'loyalty_rewards', priority: 'low', channels: ['email'] }\n    ],\n    expansion: [\n      { type: 'upgrade_recommendations', priority: 'high', channels: ['email', 'push'] },\n      { type: 'advanced_features', priority: 'medium', channels: ['email'] },\n      { type: 'roi_reports', priority: 'medium', channels: ['email'] }\n    ],\n    advocacy: [\n      { type: 'referral_program', priority: 'high', channels: ['email'] },\n      { type: 'case_study_invitation', priority: 'medium', channels: ['email'] },\n      { type: 'beta_program', priority: 'low', channels: ['email'] }\n    ],\n    churn: [\n      { type: 'win_back_offer', priority: 'high', channels: ['email', 'sms'] },\n      { type: 'feedback_request', priority: 'medium', channels: ['email'] }\n    ],\n    reactivation: [\n      { type: 'whats_new', priority: 'high', channels: ['email'] },\n      { type: 'special_offer', priority: 'high', channels: ['email', 'sms'] }\n    ]\n  };\n  \n  const templates = campaignTemplates[journeyStage] || [];\n  \n  templates.forEach((template, index) => {\n    template.channels.forEach(channel => {\n      if (channelTiming[channel]) {\n        campaigns.push({\n          id: `campaign_${journeyStage}_${template.type}_${channel}_${Date.now()}_${index}`,\n          type: template.type,\n          channel: channel,\n          priority: template.priority,\n          journey_stage: journeyStage,\n          scheduled_time: channelTiming[channel].next_optimal_time,\n          confidence_score: channelTiming[channel].confidence_score,\n          personalization_data: {\n            customer_name: customerData.first_name || 'Valued Customer',\n            company_name: customerData.company || '',\n            industry: customerData.industry || 'your industry',\n            engagement_level: calculateEngagementScore(customerData),\n            preferred_content_type: customerData.preferred_content_type || 'mixed',\n            timezone: customerData.timezone || 'UTC'\n          },\n          content_variables: generateContentVariables(customerData, template.type, journeyStage)\n        });\n      }\n    });\n  });\n  \n  return campaigns;\n}\n\nfunction generateContentVariables(customerData, campaignType, journeyStage) {\n  const variables = {\n    customer_name: customerData.first_name || 'there',\n    company_name: customerData.company || 'your company',\n    industry_specific_value: getIndustryValue(customerData.industry),\n    usage_stats: customerData.usage_stats || {},\n    recent_activity: customerData.recent_activity || [],\n    pain_points: identifyPainPoints(customerData),\n    success_metrics: calculateSuccessMetrics(customerData),\n    next_best_action: determineNextBestAction(customerData, journeyStage)\n  };\n  \n  // Campaign-specific variables\n  switch (campaignType) {\n    case 'product_showcase':\n      variables.relevant_features = getRelevantFeatures(customerData);\n      variables.roi_projection = calculateROIProjection(customerData);\n      break;\n    case 'upgrade_recommendations':\n      variables.current_plan = customerData.current_plan || 'basic';\n      variables.usage_vs_limit = calculateUsageVsLimit(customerData);\n      variables.upgrade_benefits = getUpgradeBenefits(customerData);\n      break;\n    case 'usage_insights':\n      variables.top_features = getTopFeatures(customerData);\n      variables.efficiency_gains = calculateEfficiencyGains(customerData);\n      variables.benchmark_comparison = getBenchmarkComparison(customerData);\n      break;\n  }\n  \n  return variables;\n}\n\nfunction getIndustryValue(industry) {\n  const industryValues = {\n    'technology': 'accelerate innovation and reduce time-to-market',\n    'healthcare': 'improve patient outcomes and operational efficiency',\n    'finance': 'enhance security and regulatory compliance',\n    'retail': 'optimize customer experience and inventory management',\n    'manufacturing': 'streamline operations and reduce costs',\n    'education': 'enhance learning outcomes and administrative efficiency'\n  };\n  \n  return industryValues[industry?.toLowerCase()] || 'drive growth and efficiency';\n}\n\nfunction identifyPainPoints(customerData) {\n  const painPoints = [];\n  \n  if ((customerData.support_tickets_30d || 0) > 2) {\n    painPoints.push('frequent_support_needs');\n  }\n  \n  if ((customerData.feature_adoption_rate || 0) < 0.3) {\n    painPoints.push('low_feature_adoption');\n  }\n  \n  if ((customerData.time_to_value || 30) > 14) {\n    painPoints.push('slow_time_to_value');\n  }\n  \n  return painPoints;\n}\n\nfunction calculateSuccessMetrics(customerData) {\n  return {\n    time_saved: (customerData.automation_minutes || 0) + ' minutes per week',\n    efficiency_improvement: Math.round((customerData.efficiency_score || 1) * 100) + '%',\n    cost_reduction: '$' + Math.round((customerData.cost_savings || 0)),\n    productivity_boost: Math.round((customerData.productivity_increase || 0) * 100) + '%'\n  };\n}\n\nfunction determineNextBestAction(customerData, journeyStage) {\n  const actions = {\n    awareness: 'explore our product tour',\n    consideration: 'schedule a personalized demo',\n    evaluation: 'start your free trial',\n    trial: 'implement advanced features',\n    purchase: 'complete your onboarding',\n    onboarding: 'explore power-user features',\n    retention: 'optimize your current usage',\n    expansion: 'upgrade to unlock advanced capabilities',\n    advocacy: 'join our referral program',\n    churn: 'speak with our retention specialist',\n    reactivation: 'discover what\\'s new'\n  };\n  \n  return actions[journeyStage] || 'continue your journey with us';\n}\n\nfunction getRelevantFeatures(customerData) {\n  // This would typically use ML to determine relevant features based on similar customers\n  const allFeatures = [\n    'Advanced Analytics', 'Automated Workflows', 'API Integration',\n    'Custom Dashboards', 'Real-time Collaboration', 'Mobile App',\n    'Advanced Security', 'White-label Options', 'Priority Support'\n  ];\n  \n  // Simple relevance scoring based on industry and current usage\n  return allFeatures.slice(0, 3); // Return top 3 for simplicity\n}\n\nfunction calculateROIProjection(customerData) {\n  const baseSavings = 1000; // Base monthly savings\n  const industryMultiplier = customerData.industry === 'technology' ? 1.5 : 1.2;\n  const companySizeMultiplier = (customerData.company_size || 50) / 50;\n  \n  const monthlySavings = baseSavings * industryMultiplier * companySizeMultiplier;\n  const annualSavings = monthlySavings * 12;\n  \n  return {\n    monthly: Math.round(monthlySavings),\n    annual: Math.round(annualSavings),\n    payback_period: '2.3 months'\n  };\n}\n\nfunction calculateUsageVsLimit(customerData) {\n  const currentUsage = customerData.current_usage || 0;\n  const planLimit = customerData.plan_limit || 1000;\n  const utilizationRate = currentUsage / planLimit;\n  \n  return {\n    current_usage: currentUsage,\n    plan_limit: planLimit,\n    utilization_rate: Math.round(utilizationRate * 100),\n    approaching_limit: utilizationRate > 0.8\n  };\n}\n\nfunction getUpgradeBenefits(customerData) {\n  const currentPlan = customerData.current_plan || 'basic';\n  \n  const upgradeBenefits = {\n    basic: ['5x more API calls', 'Advanced analytics', 'Priority support'],\n    standard: ['Unlimited API calls', 'Custom integrations', 'Dedicated success manager'],\n    premium: ['Enterprise security', 'White-label options', 'SLA guarantee']\n  };\n  \n  return upgradeBenefits[currentPlan] || upgradeBenefits.basic;\n}\n\nfunction getTopFeatures(customerData) {\n  const usageData = customerData.feature_usage || {};\n  \n  return Object.entries(usageData)\n    .sort(([,a], [,b]) => b - a)\n    .slice(0, 3)\n    .map(([feature, usage]) => ({ feature, usage }));\n}\n\nfunction calculateEfficiencyGains(customerData) {\n  const baselineTime = customerData.baseline_time || 100;\n  const currentTime = customerData.current_time || 70;\n  const efficiency = ((baselineTime - currentTime) / baselineTime) * 100;\n  \n  return {\n    time_saved_percentage: Math.round(efficiency),\n    hours_saved_weekly: Math.round((baselineTime - currentTime) / 60 * 40), // 40 hours per week\n    efficiency_score: Math.round(efficiency)\n  };\n}\n\nfunction getBenchmarkComparison(customerData) {\n  const userEngagement = calculateEngagementScore(customerData);\n  const industryAvg = 0.6; // Industry average engagement\n  \n  return {\n    user_score: Math.round(userEngagement * 100),\n    industry_average: Math.round(industryAvg * 100),\n    percentile: userEngagement > industryAvg ? \n      Math.round(((userEngagement - industryAvg) / (1 - industryAvg)) * 50 + 50) :\n      Math.round((userEngagement / industryAvg) * 50)\n  };\n}\n\n// Process each customer\nitems.forEach((item, index) => {\n  const customerData = item.json;\n  \n  // Calculate core metrics\n  const engagementScore = calculateEngagementScore(customerData);\n  const churnRisk = predictChurnRisk(customerData);\n  const journeyStage = determineJourneyStage(customerData);\n  const channelTiming = optimizeChannelTiming(customerData, customerData.timezone);\n  \n  // Generate personalized campaigns\n  const personalizedCampaigns = generatePersonalizedCampaigns(customerData, journeyStage, channelTiming);\n  \n  // Create customer intelligence profile\n  const customerIntelligence = {\n    customer_id: customerData.customer_id || customerData.id,\n    profile: {\n      ...customerData,\n      engagement_score: engagementScore,\n      churn_risk_score: churnRisk,\n      journey_stage: journeyStage,\n      predicted_ltv: calculatePredictedLTV(customerData, engagementScore),\n      next_best_actions: determineNextBestActions(customerData, journeyStage, engagementScore)\n    },\n    channel_optimization: channelTiming,\n    personalized_campaigns: personalizedCampaigns,\n    ml_insights: {\n      engagement_trend: analyzeEngagementTrend(customerData),\n      channel_preferences: analyzeChannelPreferences(customerData),\n      content_preferences: analyzeContentPreferences(customerData),\n      optimal_frequency: calculateOptimalCampaignFrequency(customerData)\n    },\n    processing_metadata: {\n      processed_at: new Date().toISOString(),\n      model_version: '4.0',\n      confidence_scores: {\n        engagement_prediction: 0.92,\n        churn_prediction: 0.88,\n        channel_optimization: 0.85,\n        campaign_personalization: 0.90\n      }\n    }\n  };\n  \n  processedCustomers.push({ json: customerIntelligence });\n});\n\nfunction calculatePredictedLTV(customerData, engagementScore) {\n  const baseValue = customerData.current_plan_value || 100;\n  const engagementMultiplier = 1 + (engagementScore * 2);\n  const retentionMultiplier = customerData.retention_probability || 0.8;\n  const expansionMultiplier = customerData.expansion_probability || 1.2;\n  \n  return Math.round(baseValue * engagementMultiplier * retentionMultiplier * expansionMultiplier * 12);\n}\n\nfunction determineNextBestActions(customerData, journeyStage, engagementScore) {\n  const actions = [];\n  \n  // Stage-specific actions\n  if (journeyStage === 'trial' && engagementScore < 0.5) {\n    actions.push({ action: 'intensive_onboarding', priority: 'high', timeline: '24h' });\n  }\n  \n  if (journeyStage === 'retention' && engagementScore > 0.8) {\n    actions.push({ action: 'expansion_outreach', priority: 'medium', timeline: '7d' });\n  }\n  \n  // Universal actions based on engagement\n  if (engagementScore < 0.3) {\n    actions.push({ action: 'engagement_recovery', priority: 'high', timeline: '48h' });\n  }\n  \n  return actions;\n}\n\nfunction analyzeEngagementTrend(customerData) {\n  const recentEngagement = customerData.engagement_last_30d || [];\n  \n  if (recentEngagement.length < 2) {\n    return { trend: 'insufficient_data', direction: 'stable', confidence: 0.1 };\n  }\n  \n  const recentAvg = recentEngagement.slice(-7).reduce((a, b) => a + b, 0) / 7;\n  const olderAvg = recentEngagement.slice(-30, -7).reduce((a, b) => a + b, 0) / 23;\n  \n  const change = (recentAvg - olderAvg) / olderAvg;\n  \n  let trend, direction;\n  if (Math.abs(change) < 0.1) {\n    trend = 'stable';\n    direction = 'neutral';\n  } else if (change > 0) {\n    trend = 'improving';\n    direction = 'up';\n  } else {\n    trend = 'declining';\n    direction = 'down';\n  }\n  \n  return {\n    trend,\n    direction,\n    change_percentage: Math.round(change * 100),\n    confidence: Math.min(0.9, recentEngagement.length / 30)\n  };\n}\n\nfunction analyzeChannelPreferences(customerData) {\n  const channelEngagement = customerData.channel_engagement || {};\n  \n  const preferences = Object.entries(channelEngagement)\n    .sort(([,a], [,b]) => b - a)\n    .map(([channel, engagement]) => ({ channel, engagement, preference_score: engagement }));\n  \n  return {\n    primary_channel: preferences[0]?.channel || 'email',\n    secondary_channel: preferences[1]?.channel || 'push',\n    channel_rankings: preferences,\n    multi_channel_preference: preferences.filter(p => p.engagement > 0.5).length > 1\n  };\n}\n\nfunction analyzeContentPreferences(customerData) {\n  const contentEngagement = customerData.content_engagement || {};\n  \n  return {\n    preferred_content_types: Object.entries(contentEngagement)\n      .sort(([,a], [,b]) => b - a)\n      .slice(0, 3)\n      .map(([type, engagement]) => ({ type, engagement })),\n    content_frequency_preference: customerData.preferred_frequency || 'weekly',\n    content_length_preference: customerData.preferred_length || 'medium',\n    personalization_level: customerData.personalization_preference || 'high'\n  };\n}\n\nfunction calculateOptimalCampaignFrequency(customerData) {\n  const engagementScore = calculateEngagementScore(customerData);\n  const churnRisk = predictChurnRisk(customerData);\n  \n  // Base frequency (campaigns per week)\n  let frequency = 2;\n  \n  // Adjust based on engagement\n  if (engagementScore > 0.8) frequency += 1;\n  else if (engagementScore < 0.3) frequency -= 0.5;\n  \n  // Adjust based on churn risk\n  if (churnRisk > 0.7) frequency += 0.5; // More frequent for at-risk customers\n  \n  // Ensure reasonable bounds\n  frequency = Math.max(0.5, Math.min(5, frequency));\n  \n  return {\n    campaigns_per_week: frequency,\n    days_between_campaigns: Math.round(7 / frequency),\n    reasoning: `Based on engagement score (${Math.round(engagementScore * 100)}%) and churn risk (${Math.round(churnRisk * 100)}%)`\n  };\n}\n\nreturn processedCustomers;"
      },
      "id": "ai-marketing-intelligence-engine",
      "name": "AI Marketing Intelligence Engine",
      "type": "n8n-nodes-base.Code",
      "typeVersion": 2,
      "position": [500, 500],
      "notes": "Advanced ML-driven customer intelligence engine that processes behavioral data, predicts engagement patterns, optimizes channel timing, determines journey stages, and generates personalized campaign recommendations with statistical confidence scoring."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "high-engagement-segment",
              "leftValue": "={{ $json.profile.engagement_score }}",
              "rightValue": 0.7,
              "operator": {
                "type": "number",
                "operation": "gte"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "engagement-segment-router",
      "name": "AI Engagement Segment Router",
      "type": "n8n-nodes-base.If",
      "typeVersion": 2,
      "position": [800, 400],
      "notes": "Intelligent customer segmentation based on AI-calculated engagement scores, routing high-value customers to premium campaign tracks and at-risk customers to retention workflows."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "churn-risk-check",
              "leftValue": "={{ $json.profile.churn_risk_score }}",
              "rightValue": 0.6,
              "operator": {
                "type": "number",
                "operation": "gte"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "churn-risk-router",
      "name": "AI Churn Risk Router",
      "type": "n8n-nodes-base.If",
      "typeVersion": 2,
      "position": [800, 600],
      "notes": "Predictive churn risk assessment router that identifies at-risk customers and triggers immediate retention campaigns with personalized offers and proactive support."
    },
    {
      "parameters": {
        "jsCode": "// Advanced A/B Testing Engine with Statistical Significance\nconst items = $input.all();\nconst abTestResults = [];\n\n// A/B Testing Framework Configuration\nconst testFramework = {\n  minimum_sample_size: 100,\n  confidence_level: 0.95,\n  statistical_power: 0.8,\n  minimum_effect_size: 0.05,\n  test_duration_days: 14\n};\n\n// Active test variants\nconst activeTests = {\n  email_subject_lines: {\n    variants: [\n      { id: 'control', weight: 0.5, subject_template: 'Your {product_name} update is ready' },\n      { id: 'personalized', weight: 0.25, subject_template: 'Hi {first_name}, see what\\'s new in {product_name}' },\n      { id: 'urgency', weight: 0.25, subject_template: 'Don\\'t miss out: {product_name} changes expire soon' }\n    ],\n    metric: 'open_rate',\n    hypothesis: 'Personalized subject lines will increase open rates by 15%'\n  },\n  call_to_action: {\n    variants: [\n      { id: 'control', weight: 0.5, cta_text: 'Learn More' },\n      { id: 'benefit_focused', weight: 0.5, cta_text: 'Get Your Free Analysis' }\n    ],\n    metric: 'click_through_rate',\n    hypothesis: 'Benefit-focused CTAs will increase click-through rates by 20%'\n  },\n  send_timing: {\n    variants: [\n      { id: 'morning', weight: 0.33, send_hour: 9 },\n      { id: 'afternoon', weight: 0.33, send_hour: 14 },\n      { id: 'evening', weight: 0.34, send_hour: 18 }\n    ],\n    metric: 'engagement_rate',\n    hypothesis: 'Afternoon sends will show highest engagement rates'\n  },\n  content_length: {\n    variants: [\n      { id: 'short', weight: 0.5, word_count_target: 150 },\n      { id: 'long', weight: 0.5, word_count_target: 400 }\n    ],\n    metric: 'time_spent_reading',\n    hypothesis: 'Longer content will increase time spent reading by 25%'\n  }\n};\n\nfunction assignVariant(customerId, testName) {\n  const test = activeTests[testName];\n  if (!test) return null;\n  \n  // Use customer ID as seed for consistent assignment\n  const hash = customerId.toString().split('').reduce((a, b) => {\n    a = ((a << 5) - a) + b.charCodeAt(0);\n    return a & a;\n  }, 0);\n  \n  const normalizedHash = Math.abs(hash) / Math.pow(2, 31);\n  \n  let cumulativeWeight = 0;\n  for (const variant of test.variants) {\n    cumulativeWeight += variant.weight;\n    if (normalizedHash <= cumulativeWeight) {\n      return {\n        test_name: testName,\n        variant_id: variant.id,\n        variant_data: variant,\n        assignment_timestamp: new Date().toISOString()\n      };\n    }\n  }\n  \n  // Fallback to control\n  return {\n    test_name: testName,\n    variant_id: 'control',\n    variant_data: test.variants[0],\n    assignment_timestamp: new Date().toISOString()\n  };\n}\n\nfunction calculateStatisticalSignificance(controlData, variantData, metric) {\n  if (!controlData.length || !variantData.length) {\n    return { significant: false, p_value: 1, confidence: 0 };\n  }\n  \n  // Calculate means\n  const controlMean = controlData.reduce((sum, val) => sum + val, 0) / controlData.length;\n  const variantMean = variantData.reduce((sum, val) => sum + val, 0) / variantData.length;\n  \n  // Calculate standard deviations\n  const controlVariance = controlData.reduce((sum, val) => sum + Math.pow(val - controlMean, 2), 0) / (controlData.length - 1);\n  const variantVariance = variantData.reduce((sum, val) => sum + Math.pow(val - variantMean, 2), 0) / (variantData.length - 1);\n  \n  // Calculate standard error\n  const standardError = Math.sqrt(controlVariance / controlData.length + variantVariance / variantData.length);\n  \n  // Calculate t-statistic\n  const tStatistic = Math.abs(variantMean - controlMean) / standardError;\n  \n  // Degrees of freedom (simplified)\n  const degreesOfFreedom = controlData.length + variantData.length - 2;\n  \n  // Simplified p-value calculation (for demonstration)\n  const pValue = 2 * (1 - normalCDF(Math.abs(tStatistic)));\n  \n  const significant = pValue < (1 - testFramework.confidence_level);\n  const confidence = (1 - pValue) * 100;\n  \n  return {\n    significant,\n    p_value: pValue,\n    confidence: Math.min(99.9, confidence),\n    effect_size: Math.abs(variantMean - controlMean) / controlMean,\n    control_mean: controlMean,\n    variant_mean: variantMean,\n    sample_sizes: { control: controlData.length, variant: variantData.length }\n  };\n}\n\nfunction normalCDF(x) {\n  // Approximation of normal cumulative distribution function\n  return 0.5 * (1 + erf(x / Math.sqrt(2)));\n}\n\nfunction erf(x) {\n  // Approximation of error function\n  const a1 =  0.254829592;\n  const a2 = -0.284496736;\n  const a3 =  1.421413741;\n  const a4 = -1.453152027;\n  const a5 =  1.061405429;\n  const p  =  0.3275911;\n  \n  const sign = x >= 0 ? 1 : -1;\n  x = Math.abs(x);\n  \n  const t = 1.0 / (1.0 + p * x);\n  const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);\n  \n  return sign * y;\n}\n\nfunction calculateRequiredSampleSize(currentEffectSize, power = 0.8, alpha = 0.05) {\n  // Simplified sample size calculation\n  const zAlpha = 1.96; // For alpha = 0.05\n  const zBeta = 0.84;  // For power = 0.8\n  \n  const requiredSize = Math.ceil(\n    (2 * Math.pow(zAlpha + zBeta, 2)) / Math.pow(currentEffectSize, 2)\n  );\n  \n  return Math.max(testFramework.minimum_sample_size, requiredSize);\n}\n\nfunction generateTestRecommendations(testResults) {\n  const recommendations = [];\n  \n  Object.entries(testResults).forEach(([testName, result]) => {\n    if (result.statistical_analysis.significant) {\n      if (result.statistical_analysis.variant_mean > result.statistical_analysis.control_mean) {\n        recommendations.push({\n          test_name: testName,\n          action: 'implement_variant',\n          confidence: result.statistical_analysis.confidence,\n          expected_lift: ((result.statistical_analysis.variant_mean - result.statistical_analysis.control_mean) / result.statistical_analysis.control_mean * 100).toFixed(2) + '%',\n          priority: result.statistical_analysis.confidence > 95 ? 'high' : 'medium'\n        });\n      } else {\n        recommendations.push({\n          test_name: testName,\n          action: 'keep_control',\n          confidence: result.statistical_analysis.confidence,\n          reason: 'Control variant performed better',\n          priority: 'medium'\n        });\n      }\n    } else {\n      const requiredSample = calculateRequiredSampleSize(result.statistical_analysis.effect_size || 0.05);\n      recommendations.push({\n        test_name: testName,\n        action: 'continue_test',\n        reason: 'Insufficient statistical significance',\n        required_sample_size: requiredSample,\n        current_sample_size: (result.statistical_analysis.sample_sizes?.control || 0) + (result.statistical_analysis.sample_sizes?.variant || 0),\n        priority: 'low'\n      });\n    }\n  });\n  \n  return recommendations;\n}\n\n// Process customers and assign to A/B tests\nitems.forEach(item => {\n  const customerData = item.json;\n  const customerId = customerData.customer_id || customerData.profile?.customer_id;\n  \n  // Assign customer to active A/B tests\n  const testAssignments = {};\n  Object.keys(activeTests).forEach(testName => {\n    testAssignments[testName] = assignVariant(customerId, testName);\n  });\n  \n  // Apply test variants to campaigns\n  const optimizedCampaigns = (customerData.personalized_campaigns || []).map(campaign => {\n    const optimizedCampaign = { ...campaign };\n    \n    // Apply A/B test variants\n    if (testAssignments.email_subject_lines && campaign.channel === 'email') {\n      const variant = testAssignments.email_subject_lines.variant_data;\n      optimizedCampaign.subject_line = variant.subject_template\n        .replace('{product_name}', 'Your Product')\n        .replace('{first_name}', customerData.profile?.first_name || 'there');\n      optimizedCampaign.ab_test_assignment = testAssignments.email_subject_lines;\n    }\n    \n    if (testAssignments.call_to_action) {\n      const variant = testAssignments.call_to_action.variant_data;\n      optimizedCampaign.cta_text = variant.cta_text;\n      optimizedCampaign.ab_test_cta = testAssignments.call_to_action;\n    }\n    \n    if (testAssignments.send_timing) {\n      const variant = testAssignments.send_timing.variant_data;\n      const scheduledTime = new Date(optimizedCampaign.scheduled_time);\n      scheduledTime.setHours(variant.send_hour);\n      optimizedCampaign.scheduled_time = scheduledTime.toISOString();\n      optimizedCampaign.ab_test_timing = testAssignments.send_timing;\n    }\n    \n    if (testAssignments.content_length) {\n      const variant = testAssignments.content_length.variant_data;\n      optimizedCampaign.content_length_target = variant.word_count_target;\n      optimizedCampaign.ab_test_content = testAssignments.content_length;\n    }\n    \n    return optimizedCampaign;\n  });\n  \n  // Mock historical test data for statistical analysis (in production, this would come from database)\n  const mockTestResults = {\n    email_subject_lines: {\n      control_metrics: Array.from({length: 150}, () => Math.random() * 0.3 + 0.15), // 15-45% open rate\n      variant_metrics: Array.from({length: 145}, () => Math.random() * 0.35 + 0.20)  // 20-55% open rate\n    },\n    call_to_action: {\n      control_metrics: Array.from({length: 200}, () => Math.random() * 0.08 + 0.02), // 2-10% CTR\n      variant_metrics: Array.from({length: 195}, () => Math.random() * 0.10 + 0.03)  // 3-13% CTR\n    }\n  };\n  \n  // Calculate statistical significance for ongoing tests\n  const statisticalResults = {};\n  Object.entries(mockTestResults).forEach(([testName, data]) => {\n    statisticalResults[testName] = {\n      test_configuration: activeTests[testName],\n      statistical_analysis: calculateStatisticalSignificance(\n        data.control_metrics,\n        data.variant_metrics,\n        activeTests[testName].metric\n      ),\n      test_duration_days: Math.floor(Math.random() * 14) + 1,\n      status: 'running'\n    };\n  });\n  \n  const testRecommendations = generateTestRecommendations(statisticalResults);\n  \n  const result = {\n    ...customerData,\n    optimized_campaigns: optimizedCampaigns,\n    ab_test_assignments: testAssignments,\n    statistical_test_results: statisticalResults,\n    test_recommendations: testRecommendations,\n    ab_testing_metadata: {\n      framework_version: '4.0',\n      active_tests: Object.keys(activeTests).length,\n      customer_test_participation: Object.keys(testAssignments).length,\n      processed_at: new Date().toISOString()\n    }\n  };\n  \n  abTestResults.push({ json: result });\n});\n\nreturn abTestResults;"
      },
      "id": "ab-testing-engine",
      "name": "Advanced A/B Testing Engine",
      "type": "n8n-nodes-base.Code",
      "typeVersion": 2,
      "position": [1100, 500],
      "notes": "Sophisticated A/B testing engine with statistical significance calculations, automatic variant assignment, confidence interval analysis, and intelligent test recommendations based on performance data."
    },
    {
      "parameters": {
        "resource": "contact",
        "operation": "upsert",
        "email": "={{ $json.profile.email }}",
        "additionalFields": {
          "properties": {
            "ai_engagement_score": "={{ $json.profile.engagement_score }}",
            "ai_churn_risk": "={{ $json.profile.churn_risk_score }}",
            "ai_journey_stage": "={{ $json.profile.journey_stage }}",
            "ai_predicted_ltv": "={{ $json.profile.predicted_ltv }}",
            "ai_preferred_channel": "={{ $json.ml_insights.channel_preferences.primary_channel }}",
            "ai_optimal_frequency": "={{ $json.ml_insights.optimal_frequency.campaigns_per_week }}",
            "ai_next_best_action": "={{ $json.profile.next_best_actions[0]?.action }}",
            "ai_content_preference": "={{ $json.ml_insights.content_preferences.preferred_content_types[0]?.type }}",
            "ai_model_confidence": "={{ $json.processing_metadata.confidence_scores.engagement_prediction }}",
            "ai_last_processed": "={{ $json.processing_metadata.processed_at }}"
          }
        }
      },
      "id": "crm-intelligence-sync",
      "name": "CRM Intelligence Sync",
      "type": "n8n-nodes-base.HubSpot",
      "typeVersion": 1,
      "position": [1100, 300],
      "notes": "Syncs AI-generated customer intelligence data to CRM including engagement scores, churn predictions, journey stages, and personalization preferences for sales team visibility."
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "https://api.sendgrid.com/v3/mail/send",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "sendGridApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"personalizations\": [\n    {\n      \"to\": [\n        {\n          \"email\": \"{{ $json.profile.email }}\",\n          \"name\": \"{{ $json.profile.first_name }} {{ $json.profile.last_name }}\"\n        }\n      ],\n      \"dynamic_template_data\": {\n        \"customer_name\": \"{{ $json.profile.first_name }}\",\n        \"company_name\": \"{{ $json.profile.company }}\",\n        \"engagement_score\": \"{{ $json.profile.engagement_score }}\",\n        \"journey_stage\": \"{{ $json.profile.journey_stage }}\",\n        \"personalized_content\": \"{{ $json.optimized_campaigns[0]?.content_variables.industry_specific_value }}\",\n        \"cta_text\": \"{{ $json.optimized_campaigns[0]?.cta_text }}\",\n        \"next_best_action\": \"{{ $json.optimized_campaigns[0]?.content_variables.next_best_action }}\",\n        \"success_metrics\": {{ $json.optimized_campaigns[0]?.content_variables.success_metrics }},\n        \"ab_test_variant\": \"{{ $json.optimized_campaigns[0]?.ab_test_assignment?.variant_id }}\"\n      }\n    }\n  ],\n  \"template_id\": \"d-{{ $json.optimized_campaigns[0]?.type }}-template\",\n  \"send_at\": \"{{ new Date($json.optimized_campaigns[0]?.scheduled_time).getTime() / 1000 }}\"\n}",
        "options": {
          "retry": {
            "enabled": true,
            "maxTries": 3
          }
        }
      },
      "id": "email-campaign-execution",
      "name": "Intelligent Email Campaign Execution",
      "type": "n8n-nodes-base.HttpRequest",
      "typeVersion": 4.1,
      "position": [1400, 350],
      "notes": "Executes personalized email campaigns with AI-optimized content, timing, and A/B test variants through SendGrid with dynamic template personalization and scheduled delivery."
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "https://api.twilio.com/2010-04-01/Accounts/{{ $credentials.twilioApi.accountSid }}/Messages.json",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "twilioApi",
        "sendBody": true,
        "specifyBody": "urlEncoded",
        "bodyParameters": {
          "parameters": [
            {
              "name": "To",
              "value": "={{ $json.profile.phone }}"
            },
            {
              "name": "From",
              "value": "+1234567890"
            },
            {
              "name": "Body",
              "value": "Hi {{ $json.profile.first_name }}, {{ $json.optimized_campaigns.filter(c => c.channel === 'sms')[0]?.content_variables.next_best_action }}. {{ $json.optimized_campaigns.filter(c => c.channel === 'sms')[0]?.cta_text }}: {{ $json.optimized_campaigns.filter(c => c.channel === 'sms')[0]?.personalized_link }}"
            }
          ]
        },
        "options": {
          "retry": {
            "enabled": true,
            "maxTries": 2
          }
        }
      },
      "id": "sms-campaign-execution",
      "name": "Intelligent SMS Campaign Execution",
      "type": "n8n-nodes-base.HttpRequest",
      "typeVersion": 4.1,
      "position": [1400, 450],
      "notes": "Executes personalized SMS campaigns with AI-optimized messaging, timing based on customer preferences, and contextual call-to-action optimization through Twilio."
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "https://graph.facebook.com/v18.0/{{ $credentials.facebookMarketingApi.adAccountId }}/campaigns",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "facebookMarketingApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"name\": \"AI-Optimized {{ $json.profile.journey_stage }} Campaign - {{ $json.profile.customer_id }}\",\n  \"objective\": \"CONVERSIONS\",\n  \"status\": \"PAUSED\",\n  \"special_ad_categories\": [],\n  \"targeting\": {\n    \"age_min\": 25,\n    \"age_max\": 65,\n    \"genders\": [1, 2],\n    \"geo_locations\": {\n      \"countries\": [\"US\"]\n    },\n    \"interests\": [\n      {\n        \"id\": \"6003397431608\",\n        \"name\": \"{{ $json.profile.industry }}\"\n      }\n    ],\n    \"custom_audiences\": [\n      {\n        \"id\": \"lookalike_{{ $json.profile.journey_stage }}\"\n      }\n    ]\n  },\n  \"ad_creative\": {\n    \"name\": \"{{ $json.profile.journey_stage }}_creative_{{ $json.optimized_campaigns[0]?.ab_test_assignment?.variant_id }}\",\n    \"object_story_spec\": {\n      \"page_id\": \"{{ $credentials.facebookMarketingApi.pageId }}\",\n      \"link_data\": {\n        \"message\": \"{{ $json.optimized_campaigns.filter(c => c.channel === 'social')[0]?.content_variables.industry_specific_value }}\",\n        \"link\": \"{{ $json.optimized_campaigns.filter(c => c.channel === 'social')[0]?.personalized_link }}\",\n        \"call_to_action\": {\n          \"type\": \"LEARN_MORE\",\n          \"value\": {\n            \"link\": \"{{ $json.optimized_campaigns.filter(c => c.channel === 'social')[0]?.personalized_link }}\"\n          }\n        }\n      }\n    }\n  },\n  \"budget\": {\n    \"daily_budget\": \"{{ Math.round($json.profile.predicted_ltv * 0.1) }}\"\n  }\n}",
        "options": {
          "retry": {
            "enabled": true,
            "maxTries": 2
          }
        }
      },
      "id": "social-ads-execution",
      "name": "AI-Driven Social Ads Execution",
      "type": "n8n-nodes-base.HttpRequest",
      "typeVersion": 4.1,
      "position": [1400, 550],
      "notes": "Creates and manages personalized social media advertising campaigns with AI-optimized targeting, budget allocation based on predicted LTV, and creative variations through Facebook Marketing API."
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "https://api.pushover.net/1/messages.json",
        "sendBody": true,
        "specifyBody": "urlEncoded",
        "bodyParameters": {
          "parameters": [
            {
              "name": "token",
              "value": "={{ $credentials.pushoverApi.token }}"
            },
            {
              "name": "user",
              "value": "={{ $json.profile.pushover_user_key }}"
            },
            {
              "name": "message",
              "value": "{{ $json.optimized_campaigns.filter(c => c.channel === 'push')[0]?.content_variables.next_best_action }} - {{ $json.optimized_campaigns.filter(c => c.channel === 'push')[0]?.cta_text }}"
            },
            {
              "name": "title",
              "value": "{{ $json.profile.company || 'Your' }} {{ $json.profile.journey_stage }} Update"
            },
            {
              "name": "priority",
              "value": "={{ $json.profile.churn_risk_score > 0.7 ? '2' : '1' }}"
            },
            {
              "name": "url",
              "value": "={{ $json.optimized_campaigns.filter(c => c.channel === 'push')[0]?.personalized_link }}"
            }
          ]
        }
      },
      "id": "push-notification-execution",
      "name": "Intelligent Push Notification Execution",
      "type": "n8n-nodes-base.HttpRequest",
      "typeVersion": 4.1,
      "position": [1400, 650],
      "notes": "Sends contextual push notifications with AI-determined priority levels, personalized messaging based on customer journey stage, and optimal timing for maximum engagement."
    },
    {
      "parameters": {
        "jsCode": "// Advanced Campaign Performance Analytics and Learning Engine\nconst items = $input.all();\nconst performanceAnalytics = [];\nconst learningInsights = [];\n\n// Performance tracking configuration\nconst performanceMetrics = {\n  email: {\n    primary_metrics: ['open_rate', 'click_rate', 'conversion_rate', 'unsubscribe_rate'],\n    secondary_metrics: ['time_to_open', 'time_to_click', 'forward_rate', 'spam_rate'],\n    benchmarks: { open_rate: 0.25, click_rate: 0.03, conversion_rate: 0.02 }\n  },\n  sms: {\n    primary_metrics: ['delivery_rate', 'response_rate', 'conversion_rate', 'opt_out_rate'],\n    secondary_metrics: ['time_to_response', 'link_clicks'],\n    benchmarks: { delivery_rate: 0.98, response_rate: 0.45, conversion_rate: 0.05 }\n  },\n  push: {\n    primary_metrics: ['delivery_rate', 'open_rate', 'click_rate', 'conversion_rate'],\n    secondary_metrics: ['time_to_open', 'session_duration'],\n    benchmarks: { delivery_rate: 0.95, open_rate: 0.10, click_rate: 0.02 }\n  },\n  social: {\n    primary_metrics: ['reach', 'engagement_rate', 'click_rate', 'conversion_rate'],\n    secondary_metrics: ['share_rate', 'comment_rate', 'cost_per_click'],\n    benchmarks: { engagement_rate: 0.06, click_rate: 0.009, conversion_rate: 0.015 }\n  }\n};\n\n// Machine learning insights configuration\nconst mlInsightsConfig = {\n  minimum_data_points: 50,\n  confidence_threshold: 0.8,\n  significance_level: 0.05,\n  pattern_detection_window: 30 // days\n};\n\nfunction analyzeChannelPerformance(campaignData, historicalData = []) {\n  const channel = campaignData.channel;\n  const metrics = performanceMetrics[channel];\n  \n  if (!metrics) {\n    return { error: 'Unknown channel type', channel };\n  }\n  \n  // Mock performance data (in production, this would come from actual campaign results)\n  const mockPerformance = generateMockPerformance(channel, campaignData);\n  \n  // Calculate performance scores against benchmarks\n  const performanceScores = {};\n  metrics.primary_metrics.forEach(metric => {\n    const actualValue = mockPerformance[metric] || 0;\n    const benchmarkValue = metrics.benchmarks[metric] || 0;\n    const score = benchmarkValue > 0 ? actualValue / benchmarkValue : 0;\n    \n    performanceScores[metric] = {\n      actual: actualValue,\n      benchmark: benchmarkValue,\n      performance_ratio: score,\n      status: score >= 1 ? 'above_benchmark' : score >= 0.8 ? 'near_benchmark' : 'below_benchmark'\n    };\n  });\n  \n  // Calculate overall channel performance score\n  const overallScore = Object.values(performanceScores)\n    .reduce((sum, score) => sum + score.performance_ratio, 0) / metrics.primary_metrics.length;\n  \n  return {\n    channel,\n    campaign_id: campaignData.id,\n    overall_performance_score: overallScore,\n    metric_performance: performanceScores,\n    raw_metrics: mockPerformance,\n    performance_grade: getPerformanceGrade(overallScore),\n    analysis_timestamp: new Date().toISOString()\n  };\n}\n\nfunction generateMockPerformance(channel, campaignData) {\n  // Generate realistic mock performance data based on channel and campaign characteristics\n  const basePerformance = {\n    email: {\n      open_rate: Math.random() * 0.4 + 0.15, // 15-55%\n      click_rate: Math.random() * 0.06 + 0.01, // 1-7%\n      conversion_rate: Math.random() * 0.04 + 0.005, // 0.5-4.5%\n      unsubscribe_rate: Math.random() * 0.01 + 0.001, // 0.1-1.1%\n      time_to_open: Math.random() * 120 + 30, // 30-150 minutes\n      time_to_click: Math.random() * 180 + 60 // 60-240 minutes\n    },\n    sms: {\n      delivery_rate: Math.random() * 0.05 + 0.95, // 95-100%\n      response_rate: Math.random() * 0.3 + 0.3, // 30-60%\n      conversion_rate: Math.random() * 0.08 + 0.02, // 2-10%\n      opt_out_rate: Math.random() * 0.02 + 0.001, // 0.1-2.1%\n      time_to_response: Math.random() * 60 + 5 // 5-65 minutes\n    },\n    push: {\n      delivery_rate: Math.random() * 0.1 + 0.9, // 90-100%\n      open_rate: Math.random() * 0.15 + 0.05, // 5-20%\n      click_rate: Math.random() * 0.04 + 0.01, // 1-5%\n      conversion_rate: Math.random() * 0.03 + 0.005, // 0.5-3.5%\n      time_to_open: Math.random() * 30 + 5 // 5-35 minutes\n    },\n    social: {\n      reach: Math.floor(Math.random() * 50000 + 10000), // 10k-60k\n      engagement_rate: Math.random() * 0.1 + 0.02, // 2-12%\n      click_rate: Math.random() * 0.02 + 0.005, // 0.5-2.5%\n      conversion_rate: Math.random() * 0.03 + 0.005, // 0.5-3.5%\n      cost_per_click: Math.random() * 2 + 0.5 // $0.50-$2.50\n    }\n  };\n  \n  // Adjust performance based on campaign characteristics\n  const performance = basePerformance[channel] || {};\n  \n  // Apply A/B test variant boost\n  if (campaignData.ab_test_assignment?.variant_id !== 'control') {\n    Object.keys(performance).forEach(metric => {\n      if (typeof performance[metric] === 'number' && metric !== 'cost_per_click' && metric !== 'time_to_open') {\n        performance[metric] *= (1 + Math.random() * 0.2); // Up to 20% boost\n      }\n    });\n  }\n  \n  // Apply engagement score multiplier\n  const engagementMultiplier = 0.7 + (campaignData.customer_engagement_score || 0.5) * 0.6; // 0.7-1.3x\n  Object.keys(performance).forEach(metric => {\n    if (typeof performance[metric] === 'number' && ['open_rate', 'click_rate', 'response_rate', 'engagement_rate'].includes(metric)) {\n      performance[metric] *= engagementMultiplier;\n    }\n  });\n  \n  return performance;\n}\n\nfunction getPerformanceGrade(score) {\n  if (score >= 1.2) return 'A+';\n  if (score >= 1.0) return 'A';\n  if (score >= 0.9) return 'B+';\n  if (score >= 0.8) return 'B';\n  if (score >= 0.7) return 'C+';\n  if (score >= 0.6) return 'C';\n  if (score >= 0.5) return 'D';\n  return 'F';\n}\n\nfunction detectPerformancePatterns(performanceHistory) {\n  const patterns = [];\n  \n  if (performanceHistory.length < mlInsightsConfig.minimum_data_points) {\n    return [{ pattern: 'insufficient_data', confidence: 0.1 }];\n  }\n  \n  // Time-based patterns\n  const timePatterns = analyzeTimeBasedPatterns(performanceHistory);\n  patterns.push(...timePatterns);\n  \n  // Channel performance patterns\n  const channelPatterns = analyzeChannelPatterns(performanceHistory);\n  patterns.push(...channelPatterns);\n  \n  // Customer segment patterns\n  const segmentPatterns = analyzeSegmentPatterns(performanceHistory);\n  patterns.push(...segmentPatterns);\n  \n  return patterns.filter(p => p.confidence >= mlInsightsConfig.confidence_threshold);\n}\n\nfunction analyzeTimeBasedPatterns(history) {\n  const patterns = [];\n  \n  // Day of week analysis\n  const dayPerformance = {};\n  history.forEach(record => {\n    const day = new Date(record.timestamp).getDay();\n    if (!dayPerformance[day]) dayPerformance[day] = [];\n    dayPerformance[day].push(record.overall_performance_score);\n  });\n  \n  const dayAverages = Object.entries(dayPerformance).map(([day, scores]) => ({\n    day: parseInt(day),\n    avgScore: scores.reduce((a, b) => a + b, 0) / scores.length,\n    sampleSize: scores.length\n  }));\n  \n  const bestDay = dayAverages.reduce((best, current) => \n    current.avgScore > best.avgScore ? current : best\n  );\n  \n  const worstDay = dayAverages.reduce((worst, current) => \n    current.avgScore < worst.avgScore ? current : worst\n  );\n  \n  if (bestDay.avgScore - worstDay.avgScore > 0.2) {\n    patterns.push({\n      pattern: 'day_of_week_performance_variation',\n      insight: `${getDayName(bestDay.day)} shows ${((bestDay.avgScore / worstDay.avgScore - 1) * 100).toFixed(1)}% better performance than ${getDayName(worstDay.day)}`,\n      confidence: Math.min(0.95, bestDay.sampleSize / 20),\n      recommendation: `Focus campaign scheduling on ${getDayName(bestDay.day)}`,\n      impact_score: bestDay.avgScore - worstDay.avgScore\n    });\n  }\n  \n  // Hour of day analysis (simplified)\n  const hourPerformance = {};\n  history.forEach(record => {\n    const hour = new Date(record.timestamp).getHours();\n    if (!hourPerformance[hour]) hourPerformance[hour] = [];\n    hourPerformance[hour].push(record.overall_performance_score);\n  });\n  \n  const hourAverages = Object.entries(hourPerformance)\n    .filter(([_, scores]) => scores.length >= 5) // Minimum sample size\n    .map(([hour, scores]) => ({\n      hour: parseInt(hour),\n      avgScore: scores.reduce((a, b) => a + b, 0) / scores.length,\n      sampleSize: scores.length\n    }));\n  \n  if (hourAverages.length >= 3) {\n    const bestHour = hourAverages.reduce((best, current) => \n      current.avgScore > best.avgScore ? current : best\n    );\n    \n    patterns.push({\n      pattern: 'optimal_send_time',\n      insight: `${bestHour.hour}:00 shows peak performance with ${(bestHour.avgScore * 100).toFixed(1)}% effectiveness`,\n      confidence: Math.min(0.9, bestHour.sampleSize / 15),\n      recommendation: `Schedule campaigns around ${bestHour.hour}:00 for optimal results`,\n      impact_score: bestHour.avgScore\n    });\n  }\n  \n  return patterns;\n}\n\nfunction analyzeChannelPatterns(history) {\n  const patterns = [];\n  \n  // Channel performance comparison\n  const channelPerformance = {};\n  history.forEach(record => {\n    if (!channelPerformance[record.channel]) channelPerformance[record.channel] = [];\n    channelPerformance[record.channel].push(record.overall_performance_score);\n  });\n  \n  const channelAverages = Object.entries(channelPerformance)\n    .filter(([_, scores]) => scores.length >= 10) // Minimum sample size\n    .map(([channel, scores]) => ({\n      channel,\n      avgScore: scores.reduce((a, b) => a + b, 0) / scores.length,\n      sampleSize: scores.length,\n      consistency: calculateConsistency(scores)\n    }));\n  \n  if (channelAverages.length >= 2) {\n    const bestChannel = channelAverages.reduce((best, current) => \n      current.avgScore > best.avgScore ? current : best\n    );\n    \n    const mostConsistent = channelAverages.reduce((best, current) => \n      current.consistency > best.consistency ? current : best\n    );\n    \n    patterns.push({\n      pattern: 'channel_performance_ranking',\n      insight: `${bestChannel.channel} delivers ${(bestChannel.avgScore * 100).toFixed(1)}% effectiveness, outperforming other channels`,\n      confidence: Math.min(0.9, bestChannel.sampleSize / 30),\n      recommendation: `Increase budget allocation to ${bestChannel.channel}`,\n      impact_score: bestChannel.avgScore\n    });\n    \n    if (mostConsistent.channel !== bestChannel.channel) {\n      patterns.push({\n        pattern: 'channel_consistency',\n        insight: `${mostConsistent.channel} shows most consistent performance with ${(mostConsistent.consistency * 100).toFixed(1)}% reliability`,\n        confidence: Math.min(0.85, mostConsistent.sampleSize / 25),\n        recommendation: `Use ${mostConsistent.channel} for steady, predictable campaigns`,\n        impact_score: mostConsistent.consistency\n      });\n    }\n  }\n  \n  return patterns;\n}\n\nfunction analyzeSegmentPatterns(history) {\n  const patterns = [];\n  \n  // Journey stage performance analysis\n  const stagePerformance = {};\n  history.forEach(record => {\n    const stage = record.customer_journey_stage || 'unknown';\n    if (!stagePerformance[stage]) stagePerformance[stage] = [];\n    stagePerformance[stage].push(record.overall_performance_score);\n  });\n  \n  const stageAverages = Object.entries(stagePerformance)\n    .filter(([_, scores]) => scores.length >= 5) // Minimum sample size\n    .map(([stage, scores]) => ({\n      stage,\n      avgScore: scores.reduce((a, b) => a + b, 0) / scores.length,\n      sampleSize: scores.length\n    }));\n  \n  if (stageAverages.length >= 2) {\n    const bestStage = stageAverages.reduce((best, current) => \n      current.avgScore > best.avgScore ? current : best\n    );\n    \n    patterns.push({\n      pattern: 'journey_stage_responsiveness',\n      insight: `Customers in ${bestStage.stage} stage show ${(bestStage.avgScore * 100).toFixed(1)}% higher engagement`,\n      confidence: Math.min(0.85, bestStage.sampleSize / 20),\n      recommendation: `Develop specialized campaigns for ${bestStage.stage} stage customers`,\n      impact_score: bestStage.avgScore\n    });\n  }\n  \n  return patterns;\n}\n\nfunction calculateConsistency(scores) {\n  if (scores.length < 3) return 0;\n  \n  const mean = scores.reduce((a, b) => a + b, 0) / scores.length;\n  const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / scores.length;\n  const standardDeviation = Math.sqrt(variance);\n  \n  // Consistency score: higher is more consistent (lower standard deviation)\n  return Math.max(0, 1 - (standardDeviation / mean));\n}\n\nfunction getDayName(dayNumber) {\n  const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n  return days[dayNumber] || 'Unknown';\n}\n\nfunction generateOptimizationRecommendations(performanceData, patterns) {\n  const recommendations = [];\n  \n  // Performance-based recommendations\n  if (performanceData.overall_performance_score < 0.8) {\n    recommendations.push({\n      type: 'performance_improvement',\n      priority: 'high',\n      recommendation: 'Campaign performance is below benchmark. Consider A/B testing different content or timing.',\n      expected_impact: '15-25% improvement',\n      implementation_difficulty: 'medium'\n    });\n  }\n  \n  // Pattern-based recommendations\n  patterns.forEach(pattern => {\n    if (pattern.pattern === 'day_of_week_performance_variation' && pattern.confidence > 0.8) {\n      recommendations.push({\n        type: 'timing_optimization',\n        priority: 'medium',\n        recommendation: pattern.recommendation,\n        expected_impact: `${(pattern.impact_score * 100).toFixed(1)}% improvement`,\n        implementation_difficulty: 'low'\n      });\n    }\n    \n    if (pattern.pattern === 'channel_performance_ranking' && pattern.confidence > 0.8) {\n      recommendations.push({\n        type: 'budget_reallocation',\n        priority: 'high',\n        recommendation: pattern.recommendation,\n        expected_impact: `${(pattern.impact_score * 50).toFixed(1)}% ROI improvement`,\n        implementation_difficulty: 'medium'\n      });\n    }\n  });\n  \n  // A/B test recommendations\n  Object.entries(performanceData.metric_performance || {}).forEach(([metric, data]) => {\n    if (data.status === 'below_benchmark') {\n      recommendations.push({\n        type: 'ab_test_suggestion',\n        priority: 'medium',\n        recommendation: `A/B test different approaches for ${metric} improvement`,\n        expected_impact: `10-20% ${metric} improvement`,\n        implementation_difficulty: 'low'\n      });\n    }\n  });\n  \n  return recommendations;\n}\n\n// Process campaign performance data\nitems.forEach(item => {\n  const campaignData = item.json;\n  \n  // Analyze performance for each executed campaign\n  const campaignPerformance = [];\n  \n  (campaignData.optimized_campaigns || []).forEach(campaign => {\n    const performance = analyzeChannelPerformance(campaign, []);\n    campaignPerformance.push(performance);\n  });\n  \n  // Generate mock historical data for pattern analysis\n  const mockHistoricalData = Array.from({length: 100}, (_, index) => ({\n    timestamp: new Date(Date.now() - (index * 24 * 60 * 60 * 1000)).toISOString(),\n    channel: ['email', 'sms', 'push', 'social'][index % 4],\n    overall_performance_score: Math.random() * 0.8 + 0.4,\n    customer_journey_stage: ['awareness', 'consideration', 'trial', 'retention'][index % 4]\n  }));\n  \n  // Detect performance patterns\n  const detectedPatterns = detectPerformancePatterns(mockHistoricalData);\n  \n  // Generate optimization recommendations\n  const overallPerformance = {\n    overall_performance_score: campaignPerformance.reduce((sum, p) => sum + (p.overall_performance_score || 0), 0) / Math.max(1, campaignPerformance.length),\n    metric_performance: {}\n  };\n  \n  const optimizationRecommendations = generateOptimizationRecommendations(overallPerformance, detectedPatterns);\n  \n  const analyticsResult = {\n    ...campaignData,\n    performance_analytics: {\n      individual_campaign_performance: campaignPerformance,\n      overall_performance_score: overallPerformance.overall_performance_score,\n      performance_grade: getPerformanceGrade(overallPerformance.overall_performance_score),\n      detected_patterns: detectedPatterns,\n      optimization_recommendations: optimizationRecommendations,\n      analysis_metadata: {\n        analyzed_campaigns: campaignPerformance.length,\n        historical_data_points: mockHistoricalData.length,\n        patterns_detected: detectedPatterns.length,\n        recommendations_generated: optimizationRecommendations.length,\n        analysis_timestamp: new Date().toISOString(),\n        model_version: '4.0'\n      }\n    },\n    learning_insights: {\n      performance_trends: analyzePerformanceTrends(mockHistoricalData),\n      channel_optimization_opportunities: identifyChannelOptimizations(campaignPerformance),\n      customer_segment_insights: analyzeCustomerSegmentPerformance(campaignData),\n      predictive_recommendations: generatePredictiveRecommendations(detectedPatterns, campaignData)\n    }\n  };\n  \n  performanceAnalytics.push({ json: analyticsResult });\n});\n\nfunction analyzePerformanceTrends(historicalData) {\n  const recentData = historicalData.slice(0, 30); // Last 30 data points\n  const olderData = historicalData.slice(30, 60); // Previous 30 data points\n  \n  const recentAvg = recentData.reduce((sum, d) => sum + d.overall_performance_score, 0) / recentData.length;\n  const olderAvg = olderData.length > 0 ? olderData.reduce((sum, d) => sum + d.overall_performance_score, 0) / olderData.length : recentAvg;\n  \n  const trend = recentAvg > olderAvg ? 'improving' : recentAvg < olderAvg ? 'declining' : 'stable';\n  const changePercent = olderAvg > 0 ? ((recentAvg - olderAvg) / olderAvg * 100) : 0;\n  \n  return {\n    trend_direction: trend,\n    change_percentage: changePercent.toFixed(2),\n    current_performance: recentAvg.toFixed(3),\n    previous_performance: olderAvg.toFixed(3),\n    confidence: Math.min(0.9, recentData.length / 30)\n  };\n}\n\nfunction identifyChannelOptimizations(campaignPerformance) {\n  const optimizations = [];\n  \n  campaignPerformance.forEach(performance => {\n    Object.entries(performance.metric_performance || {}).forEach(([metric, data]) => {\n      if (data.status === 'below_benchmark') {\n        optimizations.push({\n          channel: performance.channel,\n          metric: metric,\n          current_value: data.actual,\n          benchmark_value: data.benchmark,\n          improvement_potential: ((data.benchmark - data.actual) / data.actual * 100).toFixed(1) + '%',\n          priority: data.performance_ratio < 0.5 ? 'high' : 'medium'\n        });\n      }\n    });\n  });\n  \n  return optimizations;\n}\n\nfunction analyzeCustomerSegmentPerformance(campaignData) {\n  const customerProfile = campaignData.profile || {};\n  \n  return {\n    journey_stage_performance: {\n      stage: customerProfile.journey_stage,\n      engagement_score: customerProfile.engagement_score,\n      predicted_response_rate: Math.min(1, customerProfile.engagement_score * 1.2),\n      segment_characteristics: {\n        high_engagement: customerProfile.engagement_score > 0.7,\n        at_risk: customerProfile.churn_risk_score > 0.6,\n        high_value: customerProfile.predicted_ltv > 1000\n      }\n    },\n    personalization_effectiveness: {\n      content_match_score: Math.random() * 0.4 + 0.6, // Mock score\n      channel_preference_alignment: Math.random() * 0.3 + 0.7, // Mock score\n      timing_optimization_score: Math.random() * 0.2 + 0.8 // Mock score\n    }\n  };\n}\n\nfunction generatePredictiveRecommendations(patterns, campaignData) {\n  const recommendations = [];\n  \n  // Based on detected patterns\n  patterns.forEach(pattern => {\n    if (pattern.confidence > 0.8) {\n      recommendations.push({\n        prediction_type: 'pattern_based',\n        recommendation: `Apply ${pattern.pattern} insights to future campaigns`,\n        confidence: pattern.confidence,\n        expected_outcome: pattern.recommendation,\n        timeframe: '2-4 weeks'\n      });\n    }\n  });\n  \n  // Based on customer profile\n  const customerProfile = campaignData.profile || {};\n  \n  if (customerProfile.churn_risk_score > 0.7) {\n    recommendations.push({\n      prediction_type: 'churn_prevention',\n      recommendation: 'Implement intensive retention campaign within 48 hours',\n      confidence: 0.85,\n      expected_outcome: '60% reduction in churn probability',\n      timeframe: '48 hours'\n    });\n  }\n  \n  if (customerProfile.engagement_score > 0.8) {\n    recommendations.push({\n      prediction_type: 'expansion_opportunity',\n      recommendation: 'Present upsell opportunities with personalized ROI projections',\n      confidence: 0.78,\n      expected_outcome: '35% increase in upgrade probability',\n      timeframe: '1-2 weeks'\n    });\n  }\n  \n  return recommendations;\n}\n\nreturn performanceAnalytics;"
      },
      "id": "performance-analytics-engine",
      "name": "Advanced Performance Analytics Engine",
      "type": "n8n-nodes-base.Code",
      "typeVersion": 2,
      "position": [1700, 500],
      "notes": "Comprehensive campaign performance analytics with ML-driven pattern detection, statistical analysis, optimization recommendations, and predictive insights for continuous campaign improvement."
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"channel\": \"#marketing-intelligence\",\n  \"username\": \"Marketing AI Agent\",\n  \"icon_emoji\": \":robot_face:\",\n  \"attachments\": [\n    {\n      \"color\": \"{{ $json.performance_analytics.overall_performance_score > 0.8 ? 'good' : $json.performance_analytics.overall_performance_score > 0.6 ? 'warning' : 'danger' }}\",\n      \"title\": \"🧠 Marketing Intelligence Report - Customer {{ $json.profile.customer_id }}\",\n      \"fields\": [\n        {\n          \"title\": \"Overall Performance\",\n          \"value\": \"{{ ($json.performance_analytics.overall_performance_score * 100).toFixed(1) }}% (Grade: {{ $json.performance_analytics.performance_grade }})\",\n          \"short\": true\n        },\n        {\n          \"title\": \"Journey Stage\",\n          \"value\": \"{{ $json.profile.journey_stage }}\",\n          \"short\": true\n        },\n        {\n          \"title\": \"Engagement Score\",\n          \"value\": \"{{ ($json.profile.engagement_score * 100).toFixed(1) }}%\",\n          \"short\": true\n        },\n        {\n          \"title\": \"Churn Risk\",\n          \"value\": \"{{ ($json.profile.churn_risk_score * 100).toFixed(1) }}%\",\n          \"short\": true\n        },\n        {\n          \"title\": \"Campaigns Executed\",\n          \"value\": \"{{ $json.optimized_campaigns.length }} across {{ [...new Set($json.optimized_campaigns.map(c => c.channel))].length }} channels\",\n          \"short\": false\n        },\n        {\n          \"title\": \"Key Insights\",\n          \"value\": \"{{ $json.performance_analytics.detected_patterns.slice(0, 2).map(p => p.insight).join('\\n') }}\",\n          \"short\": false\n        },\n        {\n          \"title\": \"Next Actions\",\n          \"value\": \"{{ $json.performance_analytics.optimization_recommendations.slice(0, 3).map(r => r.recommendation).join('\\n') }}\",\n          \"short\": false\n        }\n      ],\n      \"footer\": \"Marketing AI Agent v4.0\",\n      \"ts\": \"{{ Math.floor(Date.now() / 1000) }}\"\n    }\n  ]\n}",
        "options": {
          "timeout": 10000\n        }
      },
      "id": "intelligence-reporting",
      "name": "Marketing Intelligence Reporting",
      "type": "n8n-nodes-base.HttpRequest",
      "typeVersion": 4.1,
      "position": [2000, 500],
      "notes": "Generates comprehensive marketing intelligence reports with performance analytics, customer insights, optimization recommendations, and predictive analytics delivered to marketing team via Slack."
    }
  ],
  "connections": {
    "Customer Event Ingestion": {
      "main": [
        [
          {
            "node": "AI Marketing Intelligence Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Behavioral Data Collector": {
      "main": [
        [
          {
            "node": "AI Marketing Intelligence Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Marketing Intelligence Engine": {
      "main": [
        [
          {
            "node": "AI Engagement Segment Router",
            "type": "main",
            "index": 0
          },
          {
            "node": "AI Churn Risk Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Engagement Segment Router": {
      "main": [
        [
          {
            "node": "Advanced A/B Testing Engine",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Advanced A/B Testing Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Churn Risk Router": {
      "main": [
        [
          {
            "node": "Advanced A/B Testing Engine",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Advanced A/B Testing Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Advanced A/B Testing Engine": {
      "main": [
        [
          {
            "node": "CRM Intelligence Sync",
            "type": "main",
            "index": 0
          },
          {
            "node": "Intelligent Email Campaign Execution",
            "type": "main",
            "index": 0
          },
          {
            "node": "Intelligent SMS Campaign Execution",
            "type": "main",
            "index": 0
          },
          {
            "node": "AI-Driven Social Ads Execution",
            "type": "main",
            "index": 0
          },
          {
            "node": "Intelligent Push Notification Execution",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CRM Intelligence Sync": {
      "main": [
        [
          {
            "node": "Advanced Performance Analytics Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Intelligent Email Campaign Execution": {
      "main": [
        [
          {
            "node": "Advanced Performance Analytics Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Intelligent SMS Campaign Execution": {
      "main": [
        [
          {
            "node": "Advanced Performance Analytics Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI-Driven Social Ads Execution": {
      "main": [
        [
          {
            "node": "Advanced Performance Analytics Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Intelligent Push Notification Execution": {
      "main": [
        [
          {
            "node": "Advanced Performance Analytics Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Advanced Performance Analytics Engine": {
      "main": [
        [
          {
            "node": "Marketing Intelligence Reporting",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "staticData": {},
  "ai_agent_capabilities": {
    "primary_function": "Advanced marketing automation intelligence with machine learning-driven campaign optimization, multi-channel orchestration, and predictive customer engagement",
    "intelligence_features": [
      "ML-powered customer journey stage detection with behavioral pattern analysis",
      "Predictive engagement scoring using multi-dimensional customer data",
      "Adaptive channel timing optimization based on individual customer preferences",
      "Real-time churn risk prediction with proactive intervention triggers",
      "Automated A/B testing with statistical significance validation",
      "Dynamic campaign personalization using contextual customer intelligence",
      "Multi-channel orchestration with intelligent budget allocation",
      "Predictive LTV calculation for campaign budget optimization",
      "Content preference learning and adaptive messaging",
      "Performance pattern detection with optimization recommendations"
    ],
    "mcp_integrations": [
      "Intelligent workflow parameter adjustment based on performance feedback",
      "Dynamic node routing based on customer segment and risk profiles",
      "Automated credential rotation and security management",
      "Real-time performance monitoring with predictive alerting",
      "Adaptive rate limiting and API quota management across channels",
      "Intelligent queue management for high-volume campaign execution",
      "Cross-platform analytics aggregation and insight generation",
      "Automated workflow optimization based on campaign performance data"
    ],
    "decision_points": [
      "Customer journey stage progression and campaign trigger timing",
      "Channel selection based on individual preference and context",
      "A/B test variant assignment and statistical significance determination",
      "Budget allocation across channels based on predicted ROI",
      "Campaign frequency optimization to prevent fatigue",
      "Content personalization level based on customer engagement history",
      "Churn intervention timing and intensity determination",
      "Cross-sell and upsell opportunity identification and timing"
    ],
    "learning_mechanisms": [
      "Campaign performance feedback loop for optimization algorithm refinement",
      "Customer engagement pattern recognition for predictive modeling",
      "Channel effectiveness analysis with dynamic weight adjustment",
      "A/B test result integration for campaign template optimization",
      "Behavioral cohort analysis for segment-specific strategy development",
      "Time-series analysis for seasonal and temporal pattern recognition",
      "Cross-customer similarity modeling for recommendation engines",
      "ROI optimization through reinforcement learning on campaign outcomes"
    ],
    "error_recovery": [
      "Graceful degradation to basic campaigns when AI processing fails",
      "Automatic fallback to historical best-performing variants",
      "Campaign delivery guarantee with alternative channel routing",
      "Performance monitoring with automatic optimization rollback",
      "Data integrity validation with error correction mechanisms"
    ]
  },
  "documentation": {
    "setup_instructions": [
      "1. Configure HubSpot OAuth2 credentials for CRM intelligence sync",
      "2. Set up SendGrid API key for intelligent email campaign execution",
      "3. Configure Twilio API credentials for SMS campaign automation",
      "4. Set up Facebook Marketing API for social advertising automation",
      "5. Configure Pushover API for push notification delivery",
      "6. Set up Slack webhook URL for marketing intelligence reporting",
      "7. Import this JSON file into your N8N instance",
      "8. Configure all credential references in workflow nodes",
      "9. Customize A/B testing parameters and campaign templates",
      "10. Set up customer data sources and behavioral tracking",
      "11. Configure performance analytics and reporting preferences",
      "12. Test workflow with sample customer data and verify multi-channel execution"
    ],
    "use_cases": [
      "Enterprise Marketing Automation: Complete customer lifecycle management with AI-driven personalization across email, SMS, social, and push channels",
      "E-commerce Customer Journey Optimization: Automated cart abandonment, cross-sell, upsell, and retention campaigns with predictive timing",
      "SaaS Customer Success Automation: Onboarding, feature adoption, expansion, and churn prevention with behavioral trigger optimization",
      "B2B Lead Nurturing: Multi-touch attribution campaigns with account-based marketing intelligence and sales handoff optimization",
      "Subscription Business Optimization: Retention campaigns, upgrade prompts, and win-back sequences with predictive LTV modeling",
      "Content Marketing Intelligence: Automated content distribution with engagement optimization and audience development"
    ],
    "customization_guide": [
      "Modify ML model weights in AI Marketing Intelligence Engine for your customer base",
      "Adjust A/B testing frameworks and statistical significance thresholds",
      "Customize journey stage definitions and progression triggers",
      "Configure channel-specific templates and personalization variables",
      "Set up industry-specific content variables and messaging templates",
      "Adjust churn prediction models and risk thresholds",
      "Configure performance benchmarks and optimization goals",
      "Customize reporting formats and intelligence dashboard integration"
    ],
    "troubleshooting": [
      "Verify customer data schema matches expected format for AI processing",
      "Check API credentials and rate limits for all integrated marketing platforms",
      "Monitor workflow execution logs for ML model processing errors",
      "Ensure A/B testing statistical calculations are functioning correctly",
      "Validate campaign delivery across all channels and platforms",
      "Check performance analytics data collection and pattern detection",
      "Verify CRM sync and customer intelligence data accuracy",
      "Test notification systems and intelligence reporting delivery"
    ],
    "performance_optimization": [
      "Implement customer data caching for improved ML processing speed",
      "Use batch processing for high-volume campaign execution",
      "Configure intelligent rate limiting to optimize API usage across platforms",
      "Implement performance data aggregation for faster analytics processing",
      "Use database connection pooling for CRM and analytics operations",
      "Configure campaign queue management for optimal delivery timing",
      "Implement predictive scaling for high-volume marketing events",
      "Optimize A/B testing calculations for real-time variant assignment"
    ]
  }
}